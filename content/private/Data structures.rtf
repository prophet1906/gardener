{\rtf1\ansi\deff0\deflang2057\plain\fs24\fet1
{\fonttbl
{\f0\froman Arial;}
}
{\info
{\createim\yr2022\mo5\dy23\hr10\min55}
}

\paperw11907\paperh16840\margl1800\margr1800\margt1440\margb1440
\slmult0\ltrpar\li0
{\b\fs24
Data structures 
{\field{\*\fldinst HYPERLINK "https://www.mindmeister.com/136354686"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Probabilistic
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Bloom Filter
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Graphs
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Algorithms
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Traversal
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
BFS
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Nearest elements are added to the end of query
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
DFS
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Nearest els are added to the begin of the query
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Prim apgorithm - find the minimal spanning tree
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Select any vertex
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Each step add to the tree the nearest edge with min weight
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Does represent a tree?
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
No cycles
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Linked
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11644393211/determine-whether-graph-represents-a-tree"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Longest path in graph
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11610229539/longest-path-in-graph"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Paths rom all to all
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Warshall-Floyd algorithm
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(n^3)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Link 
{\field{\*\fldinst HYPERLINK "http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=graphsDataStrucs3"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Min path
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Dijkstra algorithm
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
A*
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Improvement of Dijkstra algorithm
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Uses heuristics
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Result is sum of 2 functions: minDistance + h(x). h(x) is heuristical function
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Named 'best-first'
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Directed
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
weighted
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Dijkstra algorithm - find min distance from one vertex to anothers
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Link 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/12157244267/dijkstra-algorithm"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Impl 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/12156105945/weighted-graph-implementation"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Acyclic
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Path between two vertices
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11610436865/find-path-between-two-vertices-in-acyclic-graph"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Representing complex structures
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Modelling (networks, etc)
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
HashMap
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Implementation
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
non-threadsafe
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11352414963/implement-a-hash-table"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
hash function
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
h ^= (h >>> 20) ^ (h >>> 12);     return h ^ (h >>> 7) ^ (h >>> 4);
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Used to decrease number of collisions
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Max 8 by default
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
default initial capacity - MUST be a power of two.
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Max capacity MUST be a power of two
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
load factor
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Index of element
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
hash & (length - 1)
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
length is power of 2 so this will return 1111 bit mask
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
threadsafe
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Simple
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Lack of scalability bacause of locks
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
ConcurrentHashMap
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Segments
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Further improvement with buckets
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
coucurrencyLevel
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
if only 1 thread changes data - 1
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://habrahabr.ru/blogs/java/132884/"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Caches
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Storing data with keys
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
One of most useful data structures
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Array/List
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Algorithms
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Sorting
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Bubble sort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
One of the slowest
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(n^2)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Complete loop from 0, 1...n-1 el
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Merge sort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(nlogn)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11429901344/merge-sort"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Recusrive sort
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
After sorting left & right part we merge them: O(m+n)
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Insertion ort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Worst case: O(n^2)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Best case: O(n)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Start from 1-sorted array and go to left
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Each iteration there is a sorted array in the left part
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Bucket sort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11322669122/bucket-sort"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Quicksort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Complexity
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Worst case: O(n^2)
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Avg case: O(nlogn)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Recursive algorithm like mergesort
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Take a random pivot from list
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
All els less than pivot move to list1
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
All els greater than pivot move to list2
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Concatenate(quicksort(list1),pivot,quicksort(list2))
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Table of complexity 
{\field{\*\fldinst HYPERLINK "http://habrastorage.org/storage1/61a272a8/54806d34/69954080/310f329f.png"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Radix sort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(mk)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Sort last set of digits, then sort previous etc
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Heapsort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
in-memory
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Complexity
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
All cases: O(nlogn)
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Counting sort
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Linear time, linear space
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Used for data in small ranges
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Max increasing sequence in an array
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11647408424/find-the-max-increasing-sequence-in-array"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Complexity
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Time: O(n^2)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Memory: O(n)
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Use accumulatedLength for each element
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Min and max elements
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Recursive
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Sort (nlogn)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Find (n)
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Non-recursive
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(n)
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11433638198/recursive-and-none-recursive-algorithms-for-finding-the"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Find firt pair of dublicates
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Additional memory
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
HashMap with occurences
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(n) time O(n) worst case map
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Without additional memory
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(nlogn)
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Find common elements in 2 arrays
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11322371010/find-common-elements-in-two-arrays"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Sort both arrays: O(m) and O(n)
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Walt through both: O(m+n)
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Find a number in a sorted array
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Dichotomy method
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11271369620/find-a-number-in-a-sorted-array-with-duplicates-in"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Find a median in distributed collection on thouands of servers
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11354018328/find-the-median-of-million-rows-in-each-of-the-1000"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Median of medians
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(n)
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Maximum contigious ubsequent sum problem
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11268298516/maximal-contiguous-subsequent-sum-problem"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Walk from 0 to n-1
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
If accumulated sum is negative - reset
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
For storing indexed data
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
When element size matters (approx 8 times less than other data structures)
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Linked list
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Algorithms
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Determine whether has cycles
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11350125686/how-to-determine-whether-linked-list-has-cycles"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Idea
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
2 pointers
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
1 pointer has speed 1 el/iteration, another - 2 el/iteration
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
If they visit before the first pointer reaches the end - has cycles
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
O(n) worst case, no additional memory
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Reverse linked list
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11270405604/how-would-you-reverse-a-linked-list"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
O(n)
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
For queries
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Messaging
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Scheduling
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
In BFS, DFS algorithms
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Where number of items is unknown
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Trees
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Trie tree
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Link 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11996483234/trie-trees"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Used for storing info about words
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Easy search
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Dictionaries
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
In suggest snippets
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Binary
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Unordered
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
BST
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Ordered
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Algorithms
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Given a pre-order and post-order traversal results, restore te BST
}
\par\pard\plain
\slmult0\ltrpar\li1200
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11693722119/given-the-pre-order-and-in-order-traversing-result-of-a"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Article 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11270607051/binary-search-trees"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Storing data, easy access
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Better use balanced ones
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
In programming
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Scaling
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Trees scale not good. HashMap is better 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11997177805/trees-scaling"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Algorithms
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Generate all possible trees 
{\field{\*\fldinst HYPERLINK "http://habrahabr.ru/blogs/algorithm/93633/"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Self-balancing
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
RB tree
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Rotation
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
quite simple
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Rules
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Root: black
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Red can have only black childs
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
Black height of each leaf is const
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
AVL
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
First such structure
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Balance factor (-1, 0, 1)
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Flips
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Wiki 
{\field{\*\fldinst HYPERLINK "http://en.wikipedia.org/wiki/AVL_tree"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
For storing sorted data where access time equal to log(n) is needed
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Representing hierarchies
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
B-tree
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Complexity
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
O(logn)
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Leaves and nodes contain elements
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Links to next elements (organize single-linked list)
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
B+ tree
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Nodes don't contain data, only leaves
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Leaves organize wide list
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Easy iteration, easy deletion
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
A big plus in block systems
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Block data systems
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
File systems
}
\par\pard\plain
\slmult0\ltrpar\li1000
{\fs20
RDBMS (storing blobs?)
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
2-4 Trees
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Like B trees with 2,3 or 4 children
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Interval tree
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Queues
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
Graphics (finding overlap zones)
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
General usage
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Hierarchies
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
DOM, XML
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Fenwick tree
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Quick calculation sum of elements from i to j in arrays
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
In programming
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Element cost in data structures 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11139602761/element-cost-in-data-structures"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Priority Queue
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Pop high-priority element: O(1)
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Implementing using heap
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Space structures
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
K-D tree
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Hyperplanes
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
To the left of hyperplane - one part, to the right - second. (as a hyperplace an X axis can be used)
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Heap
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Tree
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
if B is a child node of A, then key(A) \u8805\'3f key(B)
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Translation to array
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Very simple. Rows, from left to right
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Algorithms
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Heapsort
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
For top k elements
}
\par\pard\plain
\slmult0\ltrpar\li800
{\fs20
O(nlogk)
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Heapsort (in-memory O(nlog(n))
}
\par\pard\plain
\slmult0\ltrpar\li200
{\b\fs20
Stacks
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
With const time for push, pop, min
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
O(n) additional memory for havingg min(Stepi)
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Link 
{\field{\*\fldinst HYPERLINK "http://iwillgetthatjobatgoogle.tumblr.com/post/11729549273/how-would-you-implement-a-stack-to-achieve-constant"}{\fldrslt (link)}}
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Usage
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Stacks in memory
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
In DFS
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
For saving contexts in processors
}
\par\pard\plain
\slmult0\ltrpar\li400
{\fs20
Features
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
Unknown length
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
No need to sort
}
\par\pard\plain
\slmult0\ltrpar\li600
{\fs20
O(1) of getting the head
}
\par\pard\plain
}